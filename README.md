Вариант №4


### Принцип работы

- **Базовый случай:** Если строка пустая (длина равна нулю), функция возвращает пустую строку. Это условие завершает рекурсию и не даёт ей уйти в бесконечный цикл.
- **Рекурсивный случай:** Если строка не пуста, функция вызывает сама себя для подстроки без первого символа (`s[1:]`). Затем к результату этого вызова прибавляет первый символ (`s`), тем самым постепенно собирая строку в обратном порядке.

### Ход выполнения

- На каждом уровне рекурсии строка становится короче (убирается первый символ), пока не останется пустой.
- После достижения базового случая, каждый предыдущий вызов получает результат рекурсивного вызова и дописывает к нему символ, который был “отсечён” при входе на этот уровень.
- В итоге все символы добавляются в обратном порядке, формируя перевёрнутую строку.

### Временная сложность

- Каждый вызов рекурсии делает копию подстроки и объединяет строки. Из-за роста длины результата на каждом шаге итоговая сложность — $$O(n^2)$$, где $$n$$ — длина исходной строки.

### Плюсы и минусы

- Подобный код легко читать и понимать, особенно для знакомства с рекурсией.
- Минус — неэффективность для больших строк из-за затрат на создание и объединение строк, а также глубина стека вызовов.




Временная сложность рекурсивного алгоритма реверса строки составляет $$O(n^2)$$, где $$n$$ — длина строки.

### Объяснение сложности

- **Количество вызовов функции:** Каждый символ строки обрабатывается отдельным рекурсивным вызовом, то есть всего будет выполнено $$n$$ рекурсий (для строки из $$n$$ символов).
- **Склеивание строк:** На каждом уровне рекурсии происходит объединение одной буквы с результатом всех предыдущих вызовов. В большинстве языков (например, Python, Java, C++ с std::string) операция сложения/конкатенации строк занимает время, зависящее от их длины — также до $$O(n)$$ для каждой операции при стандартной реализации.
- **Итоговая оценка:** Из-за последовательного добавления символа к увеличивающейся строке на каждом уровне, итоговая сложность — квадратичная, т.е. $$O(n^2)$$.



Вопрос №7

Временная сложность приведённого кода решения задачи N ферзей — $$O(N!)$$ (факториальная), где $$N$$ — размер доски.

### Почему $$O(N!)$$?

- На первом ряду ферзь может занимать любую из $$N$$ позиций.
- На втором ряду остаётся до $$N-1$$ безопасных позиций (без конфликта с первым ферзём).
- Далее — до $$N-2$$, $$N-3$$ и так далее по мере продвижения по рядам.
- Общее количество перебираемых вариантов приближается к перестановкам $$N$$ элементов — $$N!$$.


